
# Generated by Qodo Gen
import os
import pytest
import yaml
from src.hw_agent.core.plugin_context import PluginContext
from src.hw_agent.core.plugin_manager import PluginManager
from src.hw_agent.models.computational_asset import ComputationalAsset
from src.hw_agent.models.computational_models import ComputationalData
from src.hw_agent.models.plugin_models import PluginDefinition
from src.hw_agent.core.base_plugin import BasePlugin



@pytest.fixture
def mock_plugin_manager(mocker):
    # Patch the entire PluginManager class so no real file I/O or plugin loading occurs
    plugin_manager_patch = mocker.patch("hw_agent.core.plugin_manager.PluginManager", autospec=True)
    
    # This returns the mock class object
    mock_class = plugin_manager_patch
    # The "real" instance is mock_class.return_value
    mock_instance = mock_class.return_value

    return mock_instance

class DefaultPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
    
    def fetch_computational_data(self, plugin_context):
        return super().fetch(plugin_context)    
    
    def transform_computational_data(self, plugin_context: PluginContext, computational_data: ComputationalData) -> ComputationalAsset:
        return super().fetch_and_transform(plugin_context)  


class TestCodeUnderTest:
    
    def setup_method(self, method):
        # This runs before each test
        self.plugin_manager = PluginManager()

    # Successfully loads plugin when all conditions are met and returns plugin instance
    def test_load_plugin_success(self, mocker):
        # Arrange
        plugin_folder = "test_plugin"
        plugin_def = PluginDefinition(
            name="test_plugin",
            orchestrator_type="kubernetes",
            module="plugin_module"
        )
        plugin_instance = DefaultPlugin()
    
        mock_read_def = mocker.patch.object(self.plugin_manager, '_read_plugin_definition', return_value=plugin_def)
        mock_check_orch = mocker.patch.object(self.plugin_manager, '_is_orchestrator_type_allowed', return_value=True)
        mock_import = mocker.patch.object(self.plugin_manager, '_import_plugin_instance', return_value=plugin_instance)

        # Act
        result = self.plugin_manager._load_plugin(plugin_folder)

        # Assert
        assert result == plugin_instance
        mock_read_def.assert_called_once_with(plugin_folder)
        mock_check_orch.assert_called_once_with(plugin_def.orchestrator_type, plugin_def.name)
        mock_import.assert_called_once_with(plugin_folder, plugin_def)

    # Returns None when config.yaml is missing or invalid
    def test_load_plugin_invalid_config(self, mocker):
        # Arrange
        plugin_folder = "test_plugin"
        mock_read_def = mocker.patch.object(self.plugin_manager, '_read_plugin_definition', return_value=None)
        mock_check_orch = mocker.patch.object(self.plugin_manager, '_is_orchestrator_type_allowed')
        mock_import = mocker.patch.object(self.plugin_manager, '_import_plugin_instance')

        # Act
        result = self.plugin_manager._load_plugin(plugin_folder)

        # Assert
        assert result is None
        mock_read_def.assert_called_once_with(plugin_folder)
        mock_check_orch.assert_not_called()
        mock_import.assert_not_called()
        
               
        
    def test_read_plugin_definition_missing_required_fields(self, mocker):
        # Arrange
        plugin_name = "test_plugin"
        config_data = {
            "name": "Test Plugin",
            # Missing required 'orchestrator_type' and 'module' fields
        }
        mock_open = mocker.mock_open(read_data=yaml.dump(config_data))
        mocker.patch("builtins.open", mock_open)
        mocker.patch("os.path.isfile", return_value=True)
        mock_logger = mocker.patch.object(self.plugin_manager, 'logger')
    
        # Act
        result = self.plugin_manager._read_plugin_definition(plugin_name)
    
        # Assert
        assert result is None
        mock_logger.error.assert_called_once()
        assert "Error reading plugin definition" in mock_logger.error.call_args[0][0]
        mock_open.assert_called_once_with(os.path.join(self.plugin_manager.plugins_dir, plugin_name, 'config.yaml'), 'r')